// This directive will create a reference to the Server Function and pass that reference to the
// Client Component. When the function is called on the client, React will send a request to the
// server to execute the function and return the result.
'use server';

// Zod for type validation schema
import { z } from 'zod';
import postgres from 'postgres';
// Allows to invalidate cached data on demand for a specific path. Can be called in Server Functions
// and route handlers.
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';

const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });

const FormSchema = z.object({
    id: z.string(),
    customerId: z.string(),
    // Coerces the input into the right type -> Number(input)
    amount: z.coerce.number(),
    status: z.enum(['pending', 'paid']),
    date: z.string(),
});

// When the user submits the form for creating a new invoice, we do not have the `id` and the `date`
// fields as they are generated by the by the database operations.
const CreateInvoice = FormSchema.omit({id: true, date: true});
const UpdateInvoice = FormSchema.omit({id: true, date: true});

// Server Actions (now Server Functions) allow Client Components to call async functions executed on
// the server.

export async function createInvoice(formData: FormData) {
    // Extract the form values
    const rawFormData = {
        customerId: formData.get('customerId'),
        amount: formData.get('amount'),
        status: formData.get('status'),
    };

    // Validate the types using zod
    const { customerId, amount, status } = CreateInvoice.parse(rawFormData);

    // It is good practice to store monetary values in cents in your database to eliminate JS
    // floating-point errors and ensure greater accuracy.
    const amountInCents = amount * 100;
    // Create a new `YYYY-MM-DD` date
    const date = new Date().toISOString().split('T')[0];

    await sql`
        INSERT INTO invoices (customer_id, amount, status, date)
        VALUES (${customerId}, ${amountInCents}, ${status}, ${date})
    `;

    // Revalidate the cache for the invoices specific page path, with fresh data fetched from the
    // server
    revalidatePath('/dashboard/invoices');
    // Redirect the user back to the `/dashboard/invoices` page
    redirect('/dashboard/invoices');
}

export async function updateInvoice(id: string, formData: FormData) {
    // Extract the form values
    const rawFormData = {
        customerId: formData.get('customerId'),
        amount: formData.get('amount'),
        status: formData.get('status'),
    };

    // Validate the types using zod
    const { customerId, amount, status } = UpdateInvoice.parse(rawFormData);

    // It is good practice to store monetary values in cents in your database to eliminate JS
    // floating-point errors and ensure greater accuracy.
    const amountInCents = amount * 100;

    await sql`
        UPDATE invoices
        SET customer_id = ${customerId}, amount = ${amountInCents}, status = ${status}
        WHERE id = ${id}
    `;

    // Revalidate the cache for the invoices specific page path, with fresh data fetched from the
    // server
    revalidatePath('/dashboard/invoices');
    // Redirect the user back to the `/dashboard/invoices` page
    redirect('/dashboard/invoices');
}